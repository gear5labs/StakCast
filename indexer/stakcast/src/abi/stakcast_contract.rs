// ****
// Auto-generated by cainome do not edit.
// ****

#[derive(Debug)]
pub struct stakcast<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> stakcast<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Debug)]
pub struct stakcastReader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> stakcastReader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Market {
    pub creator: cainome::cairo_serde::ContractAddress,
    pub title: cainome::cairo_serde::ByteArray,
    pub description: cainome::cairo_serde::ByteArray,
    pub category: cainome::cairo_serde::ByteArray,
    pub start_time: u64,
    pub end_time: u64,
    pub resolution_time: u64,
    pub total_stake: cainome::cairo_serde::U256,
    pub min_stake: cainome::cairo_serde::U256,
    pub max_stake: cainome::cairo_serde::U256,
    pub num_outcomes: u32,
    pub validator: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for Market {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.creator,
            );
        __size += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.title);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.description,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.category);
        __size += u64::cairo_serialized_size(&__rust.start_time);
        __size += u64::cairo_serialized_size(&__rust.end_time);
        __size += u64::cairo_serialized_size(&__rust.resolution_time);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.total_stake);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.min_stake);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.max_stake);
        __size += u32::cairo_serialized_size(&__rust.num_outcomes);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.validator,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.creator),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.title));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.description),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.category));
        __out.extend(u64::cairo_serialize(&__rust.start_time));
        __out.extend(u64::cairo_serialize(&__rust.end_time));
        __out.extend(u64::cairo_serialize(&__rust.resolution_time));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.total_stake));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.min_stake));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.max_stake));
        __out.extend(u32::cairo_serialize(&__rust.num_outcomes));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.validator),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let creator = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&creator);
        let title = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&title);
        let description = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&description);
        let category = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&category);
        let start_time = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&start_time);
        let end_time = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&end_time);
        let resolution_time = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&resolution_time);
        let total_stake = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&total_stake);
        let min_stake = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&min_stake);
        let max_stake = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&max_stake);
        let num_outcomes = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&num_outcomes);
        let validator = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&validator);
        Ok(Market {
            creator,
            title,
            description,
            category,
            start_time,
            end_time,
            resolution_time,
            total_stake,
            min_stake,
            max_stake,
            num_outcomes,
            validator,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct MarketCreated {
    pub market_id: u32,
    pub creator: cainome::cairo_serde::ContractAddress,
    pub title: cainome::cairo_serde::ByteArray,
    pub start_time: u64,
    pub end_time: u64,
}
impl cainome::cairo_serde::CairoSerde for MarketCreated {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u32::cairo_serialized_size(&__rust.market_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.creator,
            );
        __size += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.title);
        __size += u64::cairo_serialized_size(&__rust.start_time);
        __size += u64::cairo_serialized_size(&__rust.end_time);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u32::cairo_serialize(&__rust.market_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.creator),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.title));
        __out.extend(u64::cairo_serialize(&__rust.start_time));
        __out.extend(u64::cairo_serialize(&__rust.end_time));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let market_id = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&market_id);
        let creator = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&creator);
        let title = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&title);
        let start_time = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&start_time);
        let end_time = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&end_time);
        Ok(MarketCreated {
            market_id,
            creator,
            title,
            start_time,
            end_time,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct MarketDetails {
    pub market: Market,
    pub status: MarketStatus,
    pub outcome: Option<MarketOutcome>,
}
impl cainome::cairo_serde::CairoSerde for MarketDetails {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += Market::cairo_serialized_size(&__rust.market);
        __size += MarketStatus::cairo_serialized_size(&__rust.status);
        __size += Option::<MarketOutcome>::cairo_serialized_size(&__rust.outcome);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(Market::cairo_serialize(&__rust.market));
        __out.extend(MarketStatus::cairo_serialize(&__rust.status));
        __out.extend(Option::<MarketOutcome>::cairo_serialize(&__rust.outcome));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let market = Market::cairo_deserialize(__felts, __offset)?;
        __offset += Market::cairo_serialized_size(&market);
        let status = MarketStatus::cairo_deserialize(__felts, __offset)?;
        __offset += MarketStatus::cairo_serialized_size(&status);
        let outcome = Option::<MarketOutcome>::cairo_deserialize(__felts, __offset)?;
        __offset += Option::<MarketOutcome>::cairo_serialized_size(&outcome);
        Ok(MarketDetails {
            market,
            status,
            outcome,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct MarketDisputed {
    pub market_id: u32,
    pub disputer: cainome::cairo_serde::ContractAddress,
    pub reason: starknet::core::types::Felt,
}
impl cainome::cairo_serde::CairoSerde for MarketDisputed {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u32::cairo_serialized_size(&__rust.market_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.disputer,
            );
        __size += starknet::core::types::Felt::cairo_serialized_size(&__rust.reason);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u32::cairo_serialize(&__rust.market_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.disputer),
            );
        __out.extend(starknet::core::types::Felt::cairo_serialize(&__rust.reason));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let market_id = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&market_id);
        let disputer = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&disputer);
        let reason = starknet::core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet::core::types::Felt::cairo_serialized_size(&reason);
        Ok(MarketDisputed {
            market_id,
            disputer,
            reason,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct MarketOutcome {
    pub winning_outcome: u32,
    pub resolution_details: starknet::core::types::Felt,
}
impl cainome::cairo_serde::CairoSerde for MarketOutcome {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u32::cairo_serialized_size(&__rust.winning_outcome);
        __size
            += starknet::core::types::Felt::cairo_serialized_size(
                &__rust.resolution_details,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u32::cairo_serialize(&__rust.winning_outcome));
        __out
            .extend(
                starknet::core::types::Felt::cairo_serialize(&__rust.resolution_details),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let winning_outcome = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&winning_outcome);
        let resolution_details = starknet::core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += starknet::core::types::Felt::cairo_serialized_size(&resolution_details);
        Ok(MarketOutcome {
            winning_outcome,
            resolution_details,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct MarketResolved {
    pub market_id: u32,
    pub outcome: u32,
    pub resolver: cainome::cairo_serde::ContractAddress,
    pub resolution_details: starknet::core::types::Felt,
}
impl cainome::cairo_serde::CairoSerde for MarketResolved {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u32::cairo_serialized_size(&__rust.market_id);
        __size += u32::cairo_serialized_size(&__rust.outcome);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.resolver,
            );
        __size
            += starknet::core::types::Felt::cairo_serialized_size(
                &__rust.resolution_details,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u32::cairo_serialize(&__rust.market_id));
        __out.extend(u32::cairo_serialize(&__rust.outcome));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.resolver),
            );
        __out
            .extend(
                starknet::core::types::Felt::cairo_serialize(&__rust.resolution_details),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let market_id = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&market_id);
        let outcome = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&outcome);
        let resolver = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&resolver);
        let resolution_details = starknet::core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += starknet::core::types::Felt::cairo_serialized_size(&resolution_details);
        Ok(MarketResolved {
            market_id,
            outcome,
            resolver,
            resolution_details,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Position {
    pub amount: cainome::cairo_serde::U256,
    pub outcome_index: u32,
    pub claimed: bool,
}
impl cainome::cairo_serde::CairoSerde for Position {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amount);
        __size += u32::cairo_serialized_size(&__rust.outcome_index);
        __size += bool::cairo_serialized_size(&__rust.claimed);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amount));
        __out.extend(u32::cairo_serialize(&__rust.outcome_index));
        __out.extend(bool::cairo_serialize(&__rust.claimed));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amount = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amount);
        let outcome_index = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&outcome_index);
        let claimed = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&claimed);
        Ok(Position {
            amount,
            outcome_index,
            claimed,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct PositionTaken {
    pub market_id: u32,
    pub user: cainome::cairo_serde::ContractAddress,
    pub outcome_index: u32,
    pub amount: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for PositionTaken {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u32::cairo_serialized_size(&__rust.market_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.user,
            );
        __size += u32::cairo_serialized_size(&__rust.outcome_index);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amount);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u32::cairo_serialize(&__rust.market_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.user),
            );
        __out.extend(u32::cairo_serialize(&__rust.outcome_index));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amount));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let market_id = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&market_id);
        let user = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
        let outcome_index = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&outcome_index);
        let amount = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amount);
        Ok(PositionTaken {
            market_id,
            user,
            outcome_index,
            amount,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct WinningsClaimed {
    pub market_id: u32,
    pub user: cainome::cairo_serde::ContractAddress,
    pub amount: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for WinningsClaimed {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u32::cairo_serialized_size(&__rust.market_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.user,
            );
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amount);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u32::cairo_serialize(&__rust.market_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.user),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amount));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let market_id = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&market_id);
        let user = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
        let amount = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amount);
        Ok(WinningsClaimed {
            market_id,
            user,
            amount,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Event {
    MarketCreated(MarketCreated),
    PositionTaken(PositionTaken),
    MarketResolved(MarketResolved),
    WinningsClaimed(WinningsClaimed),
    MarketDisputed(MarketDisputed),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::MarketCreated(val) => MarketCreated::cairo_serialized_size(val) + 1,
            Event::PositionTaken(val) => PositionTaken::cairo_serialized_size(val) + 1,
            Event::MarketResolved(val) => MarketResolved::cairo_serialized_size(val) + 1,
            Event::WinningsClaimed(val) => {
                WinningsClaimed::cairo_serialized_size(val) + 1
            }
            Event::MarketDisputed(val) => MarketDisputed::cairo_serialized_size(val) + 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            Event::MarketCreated(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(MarketCreated::cairo_serialize(val));
                temp
            }
            Event::PositionTaken(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(PositionTaken::cairo_serialize(val));
                temp
            }
            Event::MarketResolved(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(MarketResolved::cairo_serialize(val));
                temp
            }
            Event::WinningsClaimed(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&3usize));
                temp.extend(WinningsClaimed::cairo_serialize(val));
                temp
            }
            Event::MarketDisputed(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&4usize));
                temp.extend(MarketDisputed::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::MarketCreated(
                        MarketCreated::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    Event::PositionTaken(
                        PositionTaken::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    Event::MarketResolved(
                        MarketResolved::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            3usize => {
                Ok(
                    Event::WinningsClaimed(
                        WinningsClaimed::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            4usize => {
                Ok(
                    Event::MarketDisputed(
                        MarketDisputed::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("MarketCreated")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MarketCreated"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let market_id = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "market_id",
                            "MarketCreated", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&market_id);
            let creator = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "creator",
                            "MarketCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &creator,
                );
            let title = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "title",
                            "MarketCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&title);
            let start_time = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "start_time",
                            "MarketCreated", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&start_time);
            let end_time = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "end_time",
                            "MarketCreated", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&end_time);
            return Ok(
                Event::MarketCreated(MarketCreated {
                    market_id,
                    creator,
                    title,
                    start_time,
                    end_time,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("PositionTaken")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "PositionTaken"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let market_id = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "market_id",
                            "PositionTaken", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&market_id);
            let user = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "user",
                            "PositionTaken", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
            let outcome_index = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "outcome_index", "PositionTaken", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&outcome_index);
            let amount = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amount",
                            "PositionTaken", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&amount);
            return Ok(
                Event::PositionTaken(PositionTaken {
                    market_id,
                    user,
                    outcome_index,
                    amount,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("MarketResolved")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MarketResolved"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let market_id = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "market_id",
                            "MarketResolved", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&market_id);
            let outcome = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "outcome",
                            "MarketResolved", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&outcome);
            let resolver = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "resolver",
                            "MarketResolved", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &resolver,
                );
            let resolution_details = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "resolution_details", "MarketResolved", e
                        ),
                    );
                }
            };
            data_offset
                += starknet::core::types::Felt::cairo_serialized_size(
                    &resolution_details,
                );
            return Ok(
                Event::MarketResolved(MarketResolved {
                    market_id,
                    outcome,
                    resolver,
                    resolution_details,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("WinningsClaimed")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "WinningsClaimed"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let market_id = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "market_id",
                            "WinningsClaimed", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&market_id);
            let user = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "user",
                            "WinningsClaimed", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
            let amount = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amount",
                            "WinningsClaimed", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&amount);
            return Ok(
                Event::WinningsClaimed(WinningsClaimed {
                    market_id,
                    user,
                    amount,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("MarketDisputed")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MarketDisputed"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let market_id = match u32::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "market_id",
                            "MarketDisputed", e
                        ),
                    );
                }
            };
            data_offset += u32::cairo_serialized_size(&market_id);
            let disputer = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "disputer",
                            "MarketDisputed", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &disputer,
                );
            let reason = match starknet::core::types::Felt::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "reason",
                            "MarketDisputed", e
                        ),
                    );
                }
            };
            data_offset += starknet::core::types::Felt::cairo_serialized_size(&reason);
            return Ok(
                Event::MarketDisputed(MarketDisputed {
                    market_id,
                    disputer,
                    reason,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum MarketStatus {
    Active,
    Closed,
    Resolved,
    Disputed,
    Cancelled,
}
impl cainome::cairo_serde::CairoSerde for MarketStatus {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            MarketStatus::Active => 1,
            MarketStatus::Closed => 1,
            MarketStatus::Resolved => 1,
            MarketStatus::Disputed => 1,
            MarketStatus::Cancelled => 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            MarketStatus::Active => usize::cairo_serialize(&0usize),
            MarketStatus::Closed => usize::cairo_serialize(&1usize),
            MarketStatus::Resolved => usize::cairo_serialize(&2usize),
            MarketStatus::Disputed => usize::cairo_serialize(&3usize),
            MarketStatus::Cancelled => usize::cairo_serialize(&4usize),
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => Ok(MarketStatus::Active),
            1usize => Ok(MarketStatus::Closed),
            2usize => Ok(MarketStatus::Resolved),
            3usize => Ok(MarketStatus::Disputed),
            4usize => Ok(MarketStatus::Cancelled),
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "MarketStatus"),
                    ),
                );
            }
        }
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> stakcast<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_market_details(
        &self,
        market_id: &u32,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, MarketDetails> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_market_details"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_market_stats(
        &self,
        market_id: &u32,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        (cainome::cairo_serde::U256, Vec<cainome::cairo_serde::U256>),
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_market_stats"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_stake_token(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_stake_token"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_user_position(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
        market_id: &u32,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Position> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_user_position"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn assign_validator_getcall(
        &self,
        market_id: &u32,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("assign_validator"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn assign_validator(
        &self,
        market_id: &u32,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("assign_validator"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn cancel_market_getcall(
        &self,
        market_id: &u32,
        reason: &starknet::core::types::Felt,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(reason));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("cancel_market"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn cancel_market(
        &self,
        market_id: &u32,
        reason: &starknet::core::types::Felt,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(reason));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("cancel_market"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn claim_winnings_getcall(
        &self,
        market_id: &u32,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("claim_winnings"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn claim_winnings(&self, market_id: &u32) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("claim_winnings"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_market_getcall(
        &self,
        title: &cainome::cairo_serde::ByteArray,
        description: &cainome::cairo_serde::ByteArray,
        category: &cainome::cairo_serde::ByteArray,
        start_time: &u64,
        end_time: &u64,
        outcomes: &Vec<starknet::core::types::Felt>,
        min_stake: &cainome::cairo_serde::U256,
        max_stake: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(title));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(description));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(category));
        __calldata.extend(u64::cairo_serialize(start_time));
        __calldata.extend(u64::cairo_serialize(end_time));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(outcomes));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(min_stake));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(max_stake));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_market"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_market(
        &self,
        title: &cainome::cairo_serde::ByteArray,
        description: &cainome::cairo_serde::ByteArray,
        category: &cainome::cairo_serde::ByteArray,
        start_time: &u64,
        end_time: &u64,
        outcomes: &Vec<starknet::core::types::Felt>,
        min_stake: &cainome::cairo_serde::U256,
        max_stake: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(title));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(description));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(category));
        __calldata.extend(u64::cairo_serialize(start_time));
        __calldata.extend(u64::cairo_serialize(end_time));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(outcomes));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(min_stake));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(max_stake));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_market"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn dispute_market_getcall(
        &self,
        market_id: &u32,
        reason: &starknet::core::types::Felt,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(reason));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("dispute_market"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn dispute_market(
        &self,
        market_id: &u32,
        reason: &starknet::core::types::Felt,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(starknet::core::types::Felt::cairo_serialize(reason));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("dispute_market"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn resolve_market_getcall(
        &self,
        market_id: &u32,
        winning_outcome: &u32,
        resolution_details: &starknet::core::types::Felt,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(u32::cairo_serialize(winning_outcome));
        __calldata
            .extend(starknet::core::types::Felt::cairo_serialize(resolution_details));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("resolve_market"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn resolve_market(
        &self,
        market_id: &u32,
        winning_outcome: &u32,
        resolution_details: &starknet::core::types::Felt,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(u32::cairo_serialize(winning_outcome));
        __calldata
            .extend(starknet::core::types::Felt::cairo_serialize(resolution_details));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("resolve_market"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_market_validator_getcall(
        &self,
        market_validator: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(market_validator),
            );
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_market_validator"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_market_validator(
        &self,
        market_validator: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(market_validator),
            );
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_market_validator"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn take_position_getcall(
        &self,
        market_id: &u32,
        outcome_index: &u32,
        amount: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(u32::cairo_serialize(outcome_index));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amount));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("take_position"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn take_position(
        &self,
        market_id: &u32,
        outcome_index: &u32,
        amount: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        __calldata.extend(u32::cairo_serialize(outcome_index));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amount));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("take_position"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> stakcastReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_market_details(
        &self,
        market_id: &u32,
    ) -> cainome::cairo_serde::call::FCall<P, MarketDetails> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_market_details"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_market_stats(
        &self,
        market_id: &u32,
    ) -> cainome::cairo_serde::call::FCall<
        P,
        (cainome::cairo_serde::U256, Vec<cainome::cairo_serde::U256>),
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_market_stats"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_stake_token(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_stake_token"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_user_position(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
        market_id: &u32,
    ) -> cainome::cairo_serde::call::FCall<P, Position> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        __calldata.extend(u32::cairo_serialize(market_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_user_position"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
